<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>Web Trends Greece</title>
  <style>
    .image-cell img {
      display: block;
      width: 100%;
      max-width: 200px;
      height: auto;
      margin-bottom: 10px;
    }

    /* Adjust spacing for screens larger than 600px */
    @media (min-width: 600px) {
      .image-cell img {
        margin-right: 10px;
        float: left;
      }
    }
  </style>
  <script>
    const urls = {
      proxy: 'https://cors-anywhere.herokuapp.com/',
      twitterTrends: 'https://trends24.in/greece/',
      twitterTrend: 'https://twitter.com/search?q=',
      googleTrends: {
        main: 'https://trends.google.com/trends/trendingsearches/daily?geo=GR&hl=en-US',
        rss: 'https://trends.google.com/trends/trendingsearches/daily/rss?geo=GR',
        explore: 'https://trends.google.com/trends/explore?date=now%207-d&geo=GR&q=',
      },
    };

    const constants = {
      similarityThreshold: 0.5,
      maxTrends: 10,
      reducedPointsFactor: 2.1,
    };

    async function fetchContent(url) {
      try {
        const response = await fetch(urls.proxy + url + (url.indexOf('?') > -1 ? '&' : '?') + 'cb=' + Math.random());
        if (!response.ok) {
          const link = createLink(urls.proxy, 'You must get temporary CORS access first');
          document.body.appendChild(link);
          return;
        }
        return response.text();
      } catch (error) {
        const span = document.createElement('span');
        span.textContent = 'Error: ' + error.message;
        document.body.appendChild(span);
      }
    }

    function loadScript(url) {
      return new Promise((resolve, reject) => {
        if (!document.querySelector(`script[src="${url}"]`)) {
          const script = document.createElement('script');
          script.type = 'text/javascript';
          script.src = url;
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        }
      });
    }

    function createLink(href, text) {
      const link = document.createElement('a');
      link.href = href;
      link.target = '_blank';
      link.textContent = text;
      return link;
    }

    function createHeader(title, url) {
      const header = document.createElement('h1');
      const link = createLink(url, title);
      header.appendChild(link);
      return header;
    }

    (async function () {
      const googleTrendsXMLString = await fetchContent(urls.googleTrends.rss);
      if (googleTrendsXMLString) {
        const googleTrendsXML = new DOMParser().parseFromString(googleTrendsXMLString, 'application/xml');
        processGoogleTrends(googleTrendsXML);
      }

      const twitterTrendsHTMLString = await fetchContent(urls.twitterTrends);
      if (twitterTrendsHTMLString) {
        const twitterTrendsDoc = new DOMParser().parseFromString(twitterTrendsHTMLString, 'text/html');
        processTwitterTrends(twitterTrendsDoc);
      }
    })();

    async function processGoogleTrends(xml) {

      // Create an object to hold trends data
      const globalTrends = {};

      // Get all trend card lists
      const trendCards = xml.querySelectorAll(`item:nth-of-type(-n+${constants.maxTrends})`);

      for (let i = 0; i < trendCards.length; i++) {
        const trendCard = trendCards[i];
        const title = trendCard.querySelector('title').textContent.trim();
        const searches = trendCard.getElementsByTagNameNS('https://trends.google.com/trends/trendingsearches/daily', 'approx_traffic')[0].textContent.trim();
        const description = trendCard.getElementsByTagNameNS('https://trends.google.com/trends/trendingsearches/daily', 'news_item_title')[0].textContent.trim();

        globalTrends[title] = {
          searches: searches,
          description: description
        };
      }

      const container = document.getElementById('googleTrends');

      // Prepare the report
      const header = document.createElement('h1');
      const link = document.createElement('a');
      link.href = urls.googleTrends.main;
      link.target = '_blank';
      link.textContent = 'Google Trends Greece';
      header.appendChild(link);
      container.appendChild(header);

      const table = document.createElement('table');
      table.setAttribute('border', '1');
      table.setAttribute('cellpadding', '10');
      table.setAttribute('cellspacing', '0');
      table.setAttribute('width', '100%');
      container.appendChild(table);

      const tbody = document.createElement('tbody');
      table.appendChild(tbody);

      // Loop through each sorted tag and add a row to the table
      Object.entries(globalTrends).forEach(([tag, data], i) => {

        const row = document.createElement('tr');

        const rankCell = document.createElement('td');
        rankCell.textContent = i + 1;
        rankCell.setAttribute('width', '30px');
        rankCell.setAttribute('rowspan', '2');
        row.appendChild(rankCell);

        const titleCell = document.createElement('td');
        const tagLink = document.createElement('a');
        tagLink.href = urls.googleTrends.explore + encodeURIComponent(tag);
        tagLink.target = '_blank';
        tagLink.textContent = tag;
        titleCell.appendChild(tagLink);
        row.appendChild(titleCell);

        const searchesCell = document.createElement('td');
        searchesCell.textContent = data.searches.replace(',000,000', 'M').replace(',000', 'K');
        searchesCell.setAttribute('width', '80px');
        searchesCell.setAttribute('rowspan', '2');
        row.appendChild(searchesCell);

        tbody.appendChild(row);


        const row2 = document.createElement('tr');

        const descriptionCell = document.createElement('td');
        descriptionCell.textContent = data.description;
        row2.appendChild(descriptionCell);

        tbody.appendChild(row2);
      });
    }

    async function mergeSimilarKeys(data) {
      // Load string-similarity library
      await loadScript('https://unpkg.com/string-similarity@4.0.4/umd/string-similarity.min.js');

      // Find all pairs of keys with similarity score over 0.6
      const pairs = [];
      const keys = Object.keys(data);
      for (let i = 0; i < keys.length; i++) {
        for (let j = i + 1; j < keys.length; j++) {
          const similarity = stringSimilarity.compareTwoStrings(keys[i].toLowerCase(), keys[j].toLowerCase());
          if (similarity > constants.similarityThreshold) {
            let found = false;
            for (let k = 0; k < pairs.length; k++) {
              if (pairs[k].includes(keys[i]) || pairs[k].includes(keys[j])) {
                pairs[k].push(keys[i], keys[j]);
                found = true;
                break;
              }
            }
            if (!found) {
              pairs.push([keys[i], keys[j]]);
            }
          }
        }
      }

      // Merge keys in each pair
      pairs.forEach(pair => {
        let highestPointsKey = pair[0];
        let highestPoints = data[highestPointsKey].points;
        for (let i = 1; i < pair.length; i++) {
          const key = pair[i];
          if (data[key].points > highestPoints) {
            highestPointsKey = key;
            highestPoints = data[key].points;
          }
        }
        const mergedKey = highestPointsKey;
        const mergedPoints = pair.reduce((acc, key) => acc + data[key].points, 0);
        const mergedRanks = [];
        for (let i = 0; i < data[highestPointsKey].ranks.length; i++) {
          let lowestRank = data[highestPointsKey].ranks[i];
          for (let j = 0; j < pair.length; j++) {
            const key = pair[j];
            const rank = data[key].ranks[i];
            if (rank !== undefined && (lowestRank === undefined || rank < lowestRank)) {
              lowestRank = rank;
            }
          }
          mergedRanks.push(lowestRank);
        }
        data[mergedKey] = { points: mergedPoints, ranks: mergedRanks };
        pair.forEach(key => {
          if (key !== mergedKey) {
            delete data[key];
          }
        });
      });

      return data;
    }

    async function processTwitterTrends(doc) {

      // Create an object to hold trends data
      const globalTrends = {};

      // Get all trend card lists
      const trendCards = doc.querySelectorAll('.trend-card__list');

      for (let i = 0; i < trendCards.length; i++) {
        const trendCard = trendCards[i];

        // Calculate the point system for this trend card list
        const pointSystem = [89, 55, 34, 21, 13, 8, 5, 3, 2, 1].map((point, index) => {
          const multiplier = i === 0 ? 5 : i === 1 ? 3 : 1;
          return Math.ceil(point * multiplier - (constants.reducedPointsFactor * i * (point / trendCards.length)));
        });

        const listItems = trendCard.querySelectorAll('li');

        for (let j = 0; j < Math.min(listItems.length, 10); j++) {
          const tag = listItems[j].querySelector('a').textContent;
          const currentTrendPoints = pointSystem[j];
          const currentTrendRank = j;

          if (!globalTrends[tag]) {
            globalTrends[tag] = {
              points: currentTrendPoints,
              ranks: [],
            };
          } else {
            globalTrends[tag].points += currentTrendPoints;
          }

          // If the current trend card list is one of the first two (last 2 hours), add the current title's rank to its ranks array
          if (i < 2 && globalTrends[tag].ranks[i] == null) {
            globalTrends[tag].ranks[i] = currentTrendRank;
          }
        }
      }

      const mergedTrends = await mergeSimilarKeys(globalTrends);

      // Sort the mergedTrends object by points and take the top MAX_TWITTER_TRENDS tags
      const sortedTrends = Object.entries(mergedTrends)
        .sort(([, dataA], [, dataB]) => dataB.points - dataA.points)
        .slice(0, constants.maxTrends);

      const container = document.getElementById('twitterTrends');

      // Prepare the report
      const header = document.createElement('h1');
      const link = document.createElement('a');
      link.href = urls.twitterTrends;
      link.target = '_blank';
      link.textContent = 'Twitter Trends Greece';
      header.appendChild(link);
      container.appendChild(header);

      const table = document.createElement('table');
      table.setAttribute('border', '1');
      table.setAttribute('cellpadding', '10');
      table.setAttribute('cellspacing', '0');
      table.setAttribute('width', '100%');
      container.appendChild(table);

      const tbody = document.createElement('tbody');
      table.appendChild(tbody);

      // Loop through each sorted tag and add a row to the table
      sortedTrends.forEach(([tag, data], i) => {

        // Filter out undefined and null values from the ranks array
        const filteredArr = data.ranks.filter(elm => elm !== undefined && elm !== null);
        const firstRank = data.ranks[0];

        const row = document.createElement('tr');

        const rankCell = document.createElement('td');
        rankCell.textContent = i + 1;
        rankCell.setAttribute('width', '30px');
        row.appendChild(rankCell);

        let trendCell = document.createElement('td');
        trendCell.setAttribute('align', 'center');
        trendCell.setAttribute('width', '60px');
        trendCell.setAttribute('nowrap', 'nowrap');
        let trendText = '';
        let trendColor = '#000000';
        let currentRank = ` (${firstRank + 1})`;

        // Determine the trend and set the appropriate trend text and color
        if (filteredArr.length === 1 && firstRank) {
          // Trend only appears in the first trend card (last hour)
          trendText = '🔥';
        } else if (filteredArr.length === 2) {
          const secondRank = data.ranks[1];

          if (firstRank === secondRank) {
            // Trend appears in both trend cards at the same rank
            trendText = '⬤';
          } else {
            const rankDiff = Math.abs(firstRank - secondRank);

            if (firstRank < secondRank) {
              // Trend has higher rank in the first trend card
              trendText = `▲ ${rankDiff}`;
              trendColor = "#448118";
            } else {
              // Trend has higher rank in the second trend card
              trendText = `▼ ${rankDiff}`;
              trendColor = '#b91b20';
            }
          }
        } else {
          // Trend doesn't appear in either of the trend cards
          trendText = `━`;
          currentRank = '';
        }

        trendCell.textContent = trendText + currentRank;
        trendCell.setAttribute('style', 'color:' + trendColor);
        row.appendChild(trendCell);

        const titleCell = document.createElement('td');
        const tagLink = document.createElement('a');
        tagLink.href = urls.twitterTrend + encodeURIComponent(tag);
        tagLink.target = '_blank';
        tagLink.textContent = tag;
        titleCell.appendChild(tagLink);
        row.appendChild(titleCell);

        const pointsCell = document.createElement('td');
        pointsCell.textContent = data.points;
        pointsCell.setAttribute('width', '80px');
        row.appendChild(pointsCell);

        tbody.appendChild(row);
      });
    }
  </script>
</head>

<body>
  <div id="twitterTrends"></div>
  <div id="googleTrends"></div>
</body>

</html>