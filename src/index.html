<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>Web Trends Greece</title>
  <script>
    // Set the URL to be scraped
    const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
    const twitterTrendsUrl = 'https://trends24.in/greece/';
    const twitterTrendUrl = 'https://twitter.com/search?q=';
    const googleTrendsUrl = 'https://trends.google.com/trends/trendingsearches/daily?geo=GR&hl=en-US';
    const googleTrendsRSSUrl = 'https://trends.google.com/trends/trendingsearches/daily/rss?geo=GR';
    const googleTrendUrl = 'https://trends.google.com/trends/explore?date=now%207-d&geo=GR&q=';
    const youtubeTrendsUrl = 'https://www.youtube.com/feed/trending';
    const youtubeTrendsRSSUrl = 'https://rss.app/feeds/Fbry9FdcaynO0XFl.xml';

    const SIMILARITY_THRESHOLD = 0.5;
    const MAX_TRENDS = 10;
    const REDUCED_POINTS_FACTOR = 1.9;

    // Fetch the HTML content of the website using a proxy to bypass the CORS restrictions
    fetch(proxyUrl + googleTrendsRSSUrl + '&cb=' + Math.random())
      .then(response => {
        if (!response.ok) {
          const link = document.createElement('a');
          link.href = proxyUrl;
          link.target = '_blank';
          link.textContent = 'You must get temporary CORS access first';
          document.body.appendChild(link);

          return;
        }
        return response.text();
      })
      .then(xmlString => {
        if (!xmlString) {
          // Stop processing if the response wasn't successful
          return;
        }

        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlString, 'application/xml');
        processGoogleTrends(xml);
      })
      .catch((error) => {
        const span = document.createElement('span');
        span.textContent = 'Error: ' + error.message;
        document.body.appendChild(span);
      });

    async function processGoogleTrends(xml) {

      // Create an object to hold trends data
      const globalTrends = {};

      // Get all trend card lists
      const trendCards = xml.querySelectorAll(`item:nth-of-type(-n+${MAX_TRENDS})`);

      for (let i = 0; i < trendCards.length; i++) {
        const trendCard = trendCards[i];
        const title = trendCard.querySelector('title').textContent.trim();
        const searches = trendCard.getElementsByTagNameNS('https://trends.google.com/trends/trendingsearches/daily', 'approx_traffic')[0].textContent.trim();
        const description = trendCard.querySelector('description').textContent.trim();

        globalTrends[title] = {
          searches: searches,
          description: description
        };
      }

      const container = document.getElementById('googleTrends');

      // Prepare the report
      const header = document.createElement('h1');
      const link = document.createElement('a');
      link.href = googleTrendsUrl;
      link.target = '_blank';
      link.textContent = 'Google Trends Greece';
      header.appendChild(link);
      container.appendChild(header);

      const table = document.createElement('table');
      table.setAttribute('border', '1');
      table.setAttribute('cellpadding', '10');
      table.setAttribute('cellspacing', '0');
      table.setAttribute('width', '100%');
      container.appendChild(table);

      const tbody = document.createElement('tbody');
      table.appendChild(tbody);

      // Loop through each sorted tag and add a row to the table
      Object.entries(globalTrends).forEach(([tag, data], i) => {

        const row = document.createElement('tr');

        const rankCell = document.createElement('td');
        rankCell.textContent = i + 1;
        row.appendChild(rankCell);

        const titleCell = document.createElement('td');
        const tagLink = document.createElement('a');
        tagLink.href = googleTrendUrl + encodeURIComponent(tag);
        tagLink.target = '_blank';
        tagLink.textContent = tag;
        titleCell.appendChild(tagLink);
        row.appendChild(titleCell);

        const descriptionCell = document.createElement('td');
        descriptionCell.textContent = data.description;
        row.appendChild(descriptionCell);

        const searchesCell = document.createElement('td');
        searchesCell.textContent = data.searches;
        row.appendChild(searchesCell);

        tbody.appendChild(row);
      });
    }

    // Fetch the HTML content of the website using a proxy to bypass the CORS restrictions
    fetch(proxyUrl + twitterTrendsUrl + '?cb=' + Math.random())
      .then(response => {
        if (!response.ok) {
          const link = document.createElement('a');
          link.href = proxyUrl;
          link.target = '_blank';
          link.textContent = 'You must get temporary CORS access first';
          document.body.appendChild(link);

          return;
        }
        return response.text();
      })
      .then(html => {
        if (!html) {
          // Stop processing if the response wasn't successful
          return;
        }

        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        processTwitterTrends(doc);
      })
      .catch((error) => {
        const span = document.createElement('span');
        span.textContent = 'Error: ' + error.message;
        document.body.appendChild(span);
      });

    // Load string-similarity library dynamically
    function loadScript(url) {
      return new Promise((resolve, reject) => {
        if (!document.querySelector(`script[src="${url}"]`)) {
          const script = document.createElement('script');
          script.type = 'text/javascript';
          script.src = url;
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        }
      });
    }

    async function mergeSimilarKeys(data) {
      // Load string-similarity library
      await loadScript('https://unpkg.com/string-similarity@4.0.4/umd/string-similarity.min.js');

      // Find all pairs of keys with similarity score over 0.6
      const pairs = [];
      const keys = Object.keys(data);
      for (let i = 0; i < keys.length; i++) {
        for (let j = i + 1; j < keys.length; j++) {
          const similarity = stringSimilarity.compareTwoStrings(keys[i].toLowerCase(), keys[j].toLowerCase());
          if (similarity > SIMILARITY_THRESHOLD) {
            let found = false;
            for (let k = 0; k < pairs.length; k++) {
              if (pairs[k].includes(keys[i]) || pairs[k].includes(keys[j])) {
                pairs[k].push(keys[i], keys[j]);
                found = true;
                break;
              }
            }
            if (!found) {
              pairs.push([keys[i], keys[j]]);
            }
          }
        }
      }

      // Merge keys in each pair
      pairs.forEach(pair => {
        let highestPointsKey = pair[0];
        let highestPoints = data[highestPointsKey].points;
        for (let i = 1; i < pair.length; i++) {
          const key = pair[i];
          if (data[key].points > highestPoints) {
            highestPointsKey = key;
            highestPoints = data[key].points;
          }
        }
        const mergedKey = highestPointsKey;
        const mergedPoints = pair.reduce((acc, key) => acc + data[key].points, 0);
        const mergedRanks = [];
        for (let i = 0; i < data[highestPointsKey].ranks.length; i++) {
          let lowestRank = data[highestPointsKey].ranks[i];
          for (let j = 0; j < pair.length; j++) {
            const key = pair[j];
            const rank = data[key].ranks[i];
            if (rank !== undefined && (lowestRank === undefined || rank < lowestRank)) {
              lowestRank = rank;
            }
          }
          mergedRanks.push(lowestRank);
        }
        data[mergedKey] = { points: mergedPoints, ranks: mergedRanks };
        pair.forEach(key => {
          if (key !== mergedKey) {
            delete data[key];
          }
        });
      });

      return data;
    }

    async function processTwitterTrends(doc) {

      // Create an object to hold trends data
      const globalTrends = {};

      // Get all trend card lists
      const trendCards = doc.querySelectorAll('.trend-card__list');

      for (let i = 0; i < trendCards.length; i++) {
        const trendCard = trendCards[i];

        // Calculate the point system for this trend card list
        const pointSystem = [89, 55, 34, 21, 13, 8, 5, 3, 2, 1].map(
          point => Math.ceil(point - (REDUCED_POINTS_FACTOR * i * (point / trendCards.length)))
        );

        const listItems = trendCard.querySelectorAll('li');

        for (let j = 0; j < Math.min(listItems.length, 10); j++) {
          const tag = listItems[j].querySelector('a').textContent;
          const currentTrendPoints = pointSystem[j];
          const currentTrendRank = j;

          if (!globalTrends[tag]) {
            globalTrends[tag] = {
              points: currentTrendPoints,
              ranks: [],
            };
          } else {
            globalTrends[tag].points += currentTrendPoints;
          }

          // If the current trend card list is one of the first two (last 2 hours), add the current title's rank to its ranks array
          if (i < 2 && globalTrends[tag].ranks[i] == null) {
            globalTrends[tag].ranks[i] = currentTrendRank;
          }
        }
      }

      const mergedTrends = await mergeSimilarKeys(globalTrends);

      // Sort the mergedTrends object by points and take the top MAX_TWITTER_TRENDS tags
      const sortedTrends = Object.entries(mergedTrends)
        .sort(([, dataA], [, dataB]) => dataB.points - dataA.points)
        .slice(0, MAX_TRENDS);

      const container = document.getElementById('twitterTrends');

      // Prepare the report
      const header = document.createElement('h1');
      const link = document.createElement('a');
      link.href = twitterTrendsUrl;
      link.target = '_blank';
      link.textContent = 'Twitter Trends Greece';
      header.appendChild(link);
      container.appendChild(header);

      const table = document.createElement('table');
      table.setAttribute('border', '1');
      table.setAttribute('cellpadding', '10');
      table.setAttribute('cellspacing', '0');
      table.setAttribute('width', '100%');
      container.appendChild(table);

      const tbody = document.createElement('tbody');
      table.appendChild(tbody);

      // Loop through each sorted tag and add a row to the table
      sortedTrends.forEach(([tag, data], i) => {

        // Filter out undefined and null values from the ranks array
        const filteredArr = data.ranks.filter(elm => elm !== undefined && elm !== null);
        const firstRank = data.ranks[0];

        const row = document.createElement('tr');

        const rankCell = document.createElement('td');
        rankCell.textContent = i + 1;
        row.appendChild(rankCell);

        let trendCell = document.createElement('td');
        let trendText = '';
        let trendColor = '#000000';
        let currentRank = ` (${firstRank + 1})`;

        // Determine the trend and set the appropriate trend text and color
        if (filteredArr.length === 1 && firstRank) {
          // Trend only appears in the first trend card (last hour)
          trendText = '🔥';
        } else if (filteredArr.length === 2) {
          const secondRank = data.ranks[1];

          if (firstRank === secondRank) {
            // Trend appears in both trend cards at the same rank
            trendText = '⬤';
          } else {
            const rankDiff = Math.abs(firstRank - secondRank);

            if (firstRank < secondRank) {
              // Trend has higher rank in the first trend card
              trendText = `▲ ${rankDiff}`;
              trendColor = "#448118";
            } else {
              // Trend has higher rank in the second trend card
              trendText = `▼ ${rankDiff}`;
              trendColor = '#b91b20';
            }
          }
        } else {
          // Trend doesn't appear in either of the trend cards
          trendText = `━`;
          currentRank = '';
        }

        trendCell.textContent = trendText + currentRank;
        trendCell.setAttribute('style', 'color:' + trendColor);
        row.appendChild(trendCell);

        const titleCell = document.createElement('td');
        const tagLink = document.createElement('a');
        tagLink.href = twitterTrendUrl + encodeURIComponent(tag);
        tagLink.target = '_blank';
        tagLink.textContent = tag;
        titleCell.appendChild(tagLink);
        row.appendChild(titleCell);

        const pointsCell = document.createElement('td');
        pointsCell.textContent = data.points;
        row.appendChild(pointsCell);

        tbody.appendChild(row);
      });
    }

    // Fetch the HTML content of the website using a proxy to bypass the CORS restrictions
    fetch(proxyUrl + youtubeTrendsRSSUrl + '?cb=' + Math.random())
      .then(response => {
        if (!response.ok) {
          const link = document.createElement('a');
          link.href = proxyUrl;
          link.target = '_blank';
          link.textContent = 'You must get temporary CORS access first';
          document.body.appendChild(link);

          return;
        }
        return response.text();
      })
      .then(xmlString => {
        if (!xmlString) {
          // Stop processing if the response wasn't successful
          return;
        }

        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlString, 'application/xml');
        processYoutubeTrends(xml);
      })
      .catch((error) => {
        const span = document.createElement('span');
        span.textContent = 'Error: ' + error.message;
        document.body.appendChild(span);
      });

    async function processYoutubeTrends(xml) {
      // Create an object to hold trends data
      const globalTrends = {};

      // Get all trend card lists
      const trendCards = xml.querySelectorAll(`item:nth-of-type(-n+${MAX_TRENDS})`);

      for (let i = 0; i < trendCards.length; i++) {
        const trendCard = trendCards[i];
        const title = trendCard.querySelector('title').textContent.trim();
        const link = trendCard.querySelector('link').textContent;
        const imageUrl = trendCard.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'content')[0].getAttribute('url');
        const pubDate = new Date(trendCard.querySelector('pubDate').textContent);

        globalTrends[title] = {
          link: link,
          imageUrl: imageUrl,
          pubDate: pubDate
        };
      }

      const container = document.getElementById('youtubeTrends');

      // Prepare the report
      const header = document.createElement('h1');
      const link = document.createElement('a');
      link.href = youtubeTrendsUrl;
      link.target = '_blank';
      link.textContent = 'Youtube Trends Greece';
      header.appendChild(link);
      container.appendChild(header);

      const table = document.createElement('table');
      table.setAttribute('border', '1');
      table.setAttribute('cellpadding', '10');
      table.setAttribute('cellspacing', '0');
      table.setAttribute('width', '100%');
      container.appendChild(table);

      const tbody = document.createElement('tbody');
      table.appendChild(tbody);

      // Loop through each sorted tag and add a row to the table
      Object.entries(globalTrends).forEach(([tag, data], i) => {

        const row = document.createElement('tr');

        const rankCell = document.createElement('td');
        rankCell.textContent = i + 1;
        row.appendChild(rankCell);

        const imageCell = document.createElement('td');
        imageCell.setAttribute('align', 'center');
        const image = document.createElement('img');
        image.setAttribute('src', data.imageUrl);
        image.setAttribute('style', 'width: 100%; max-width:200px; min-width:100px; height:auto;');
        imageCell.appendChild(image);
        row.appendChild(imageCell);

        const titleCell = document.createElement('td');
        const tagLink = document.createElement('a');
        tagLink.href = link;
        tagLink.target = '_blank';
        tagLink.textContent = tag;
        titleCell.appendChild(tagLink);
        row.appendChild(titleCell);

        const pubDateCell = document.createElement('td');
        pubDateCell.setAttribute('nowrap', 'nowrap');
        pubDateCell.textContent = data.pubDate.toLocaleDateString('el-GR', { day: 'numeric', month: 'short', year: 'numeric' });
        row.appendChild(pubDateCell);

        tbody.appendChild(row);
      });
    }
  </script>
</head>

<body>
  <div id="twitterTrends"></div>
  <div id="googleTrends"></div>
  <div id="youtubeTrends"></div>
</body>

</html>